<!DOCTYPE html>
<html dir="ltr">
  <head>
    <meta charset="UTF-8"/>
    <title>10.3.1.2 Message Travels Through a Network</title>
    <!-- Content -->
    <link type="text/css" rel="stylesheet" href="../../common/styles/course.css"/>
	<script type="text/javascript" src="../../common/scripts/jquery_bundle.min.js"></script>
    <script>
      var myLayout; 
      $(document).ready(function () {
    	myLayout = $('body').layout({
          west__size:300,
          stateManagement__enabled: true,
          maskContents: true,
          livePaneResizing: true,
          onresize_end: resizeTextDiv,
          stateManagement__cookie__name: "ui_pane",
          stateManagement__cookie__expires: 1,
          stateManagement__cookie__path: "/"
        });
      });
      function resizeTextDiv() {
        var DivHeight = document.getElementById("header").offsetHeight;
        document.getElementById("content").style.top = String(DivHeight) + 'px';
      }
    </script>
  </head>
  <body class="onecolumn" onLoad="resizeTextDiv()">
    <div class="ui-layout-west">
      <div id="header">
        <h1>The Message Heard Around the World</h1>
        <h2>Move It!</h2>
      </div>
      <div id="content">
          <p>The massive explosion of applications is due in large part to the genius of the layered approach for processing data through a network. Specifically, keeping the functionality of the application layer separate from the functionality of transporting the data, allows the application layer protocols to be changed and new applications to be developed, without the developer having to worry about the mechanics of getting the data across the network. That is the functionality of other layers and therefore, other developers.</p>
          <p></p>
          <p>As shown in the figure, when an application sends a request to a server application, the message is built by the application layer, but is then passed down through all the various layer functionalities on the client for delivery.  As it moves through the stack each lower layer encapsulates the data with a header that contains the protocols of communication for that layer. These protocols, which are implemented on both the sending and receiving hosts, interact to provide end-to-end delivery of applications over the network.</p>
          <p></p>
          <p>Protocols like HTTP, for example, support the delivery of web pages to end devices. Now that we have learned all the various layers and their functionalities, we can follow a client request of a web page from the web server to see how each of these independent functionalities work fully, together.</p>
          <p></p>
          <p>Using the TCP/IP model, a complete communication process includes six steps:</p>
          <p></p>
          <p>
            <b>Creation of the Data</b>
          </p>
          <p>The first step is the creation of data at the application layer of the originating source end device.  In this case, after building the web client’s request, known as an HTTP GET, that data will then be encoded, compressed, and encrypted if necessary. This is the job of the application layer protocol within the TCP/IP model – but this includes the functionality described by the application, presentation, and session layers of the OSI model. The application layer sends this data as a stream to the transport layer.</p>
          <p></p>
          <p>
            <b>Segmentation and Initial Encapsulation</b>
          </p>
          <p>The next step is segmentation and encapsulation of the data as it passes down the protocol stack. At the transport layer, the HTTP GET message will be broken down into smaller more manageable pieces and each part of the message will have a transport layer header added to it. Inside the transport layer header are indicators on how to rebuild the message. Also included is an identifier, port number 80. This is used to tell the destination server that the message is destined for its web server application. A randomly generated source port is added as well, to ensure that the client can track return communication and forward it up to the correct client application. </p>
        </div>
    </div>
    <iframe id="mainFrame" name="mainFrame" src="media/index.html" frameborder="0" class="ui-layout-center" alt="interactive graphic" longdesc="media_10.3.1.2_longdesc.txt"></iframe>
  </body>
</html>
